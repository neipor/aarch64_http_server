# ANX 架构设计

本文档详细描述了 ANX 服务器的内部架构和设计决策。

## 1. 核心哲学

ANX 的核心是事件驱动。与传统的每个连接一个进程/线程模型不同，ANX 在一个单独的进程中运行一个事件循环，使用非阻塞I/O来高效地处理成千上万的并发连接。

## 2. 事件处理模型

我们将使用 Linux 提供的 `epoll` 机制。

1.  **`epoll_create1`**: 在服务器启动时创建一个 `epoll` 实例。
2.  **`epoll_ctl`**:
    *   将监听服务器 `socket` 的 `EPOLLIN` (可读) 事件添加到 `epoll` 实例中。
    *   当一个新的客户端连接被 `accept` 时，将新的 `socket` 设置为非阻塞，并将其 `EPOLLIN` 事件也添加到 `epoll` 实例。
3.  **`epoll_wait`**: 在主循环中调用，阻塞等待直到一个或多个事件发生。
4.  **事件分发**: `epoll_wait` 返回后，遍历所有就绪的事件。
    *   如果是监听 `socket` 的可读事件，则调用 `accept` 接受新连接。
    *   如果是客户端 `socket` 的可读事件，则调用 `read` 读取请求数据。
    *   如果是客户端 `socket` 的可写事件（当写入缓冲区可用时），则调用 `write` 发送响应数据。

## 3. 内存管理

在汇编中，所有内存都需要手动管理。
- 请求和响应缓冲区将在 `.bss` 段中预先分配，或者在需要时通过 `brk` 系统调用动态分配。
- 我们需要极其小心地处理缓冲区大小，防止缓冲区溢出。

## 4. 数据结构

我们将为每个连接维护一个状态结构，至少包含：
- 文件描述符 (FD)
- 当前状态 (例如，`STATE_READING`, `STATE_WRITING`)
- 请求缓冲区指针和长度
- 响应缓冲区指针和长度 